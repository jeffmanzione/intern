#ifndef COM_GITHUB_JEFFMANZIONE_INTERN_INTERN_H_
#define COM_GITHUB_JEFFMANZIONE_INTERN_INTERN_H_

/**
 * @file intern.h
 * @brief Generic macro-based intern pool supporting optional thread safety.
 *
 * The pool stores immutable values contiguously inside fixed-size memory
 * chunks and deduplicates them using a hash set. A readerâ€“writer lock
 * optionally guards concurrent access.
 *
 * Usage:
 *    DEFINE_INTERN_POOL(MyStrings, char)
 *    IMPL_INTERN_POOL(MyStrings, char)
 */

#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

#include "intern/internal/hash_set.h"
#include "intern/internal/intern_helpers.h"
#include "intern/internal/rwlock.h"

#define DEFAULT_MAX_VALUES_PER_CHUNK 64

#define MAX_VALUE(a, b) (((a) > (b)) ? (a) : (b))

/**
 * DEFINE_INTERN_POOL(name, value_type)
 *
 * Generates:
 *   - Hash set types for storing value_type*
 *   - Chunk struct for contiguous allocation
 *   - Intern pool struct containing:
 *       threadsafe flag
 *       contiguous chunk list
 *       hash set
 *       optional RWLock
 *   - Functions:
 *       name_init, name_finalize, name_intern
 *
 * Internally, values are copied into a chain of chunks for compact storage.
 */
#define DEFINE_INTERN_POOL(name, value_type)                           \
  DEFINE_HASH_SET(name##HashSet, value_type *);                        \
                                                                       \
  typedef name##HashSetHashFn name##HashFn;                            \
  typedef name##HashSetCompareFn name##CompareFn;                      \
  typedef struct name##Chunk_ name##Chunk;                             \
                                                                       \
  typedef struct {                                                     \
    bool threadsafe;                                                   \
    char *tail; /* Current write cursor in the active chunk */         \
    char *end;  /* End pointer of the active chunk */                  \
    name##Chunk *chunk;                                                \
    name##Chunk *last; /* Tail of the chunk chain */                   \
    name##HashSet hash_set;                                            \
    RWLock rwlock;                                                     \
  } name;                                                              \
                                                                       \
  void name##_init(name *pool, bool threadsafe, name##HashFn hash,     \
                   name##CompareFn compare);                           \
  void name##_finalize(name *pool);                                    \
  const value_type *name##_intern(name *pool, const value_type *value, \
                                  uint32_t value_size);

/**
 * IMPL_INTERN_POOL(name, value_type)
 *
 * Defines structures and functions generated by DEFINE_INTERN_POOL.
 */
#define IMPL_INTERN_POOL(name, value_type)                                     \
  IMPL_HASH_SET(name##HashSet, value_type *);                                  \
                                                                               \
  struct name##Chunk_ {                                                        \
    char *block; /* Raw memory storage */                                      \
    name##Chunk *next;                                                         \
    uint32_t sz; /* Size in bytes */                                           \
  };                                                                           \
                                                                               \
  /* Allocate a new chunk to store value bytes contiguously */                 \
  static name##Chunk *name##Chunk_create(uint32_t chunk_size) {                \
    name##Chunk *chunk = (name##Chunk *)malloc(sizeof(name##Chunk));           \
    if (!chunk) return NULL;                                                   \
    chunk->sz = chunk_size;                                                    \
    chunk->block = (char *)malloc(chunk_size);                                 \
    if (!chunk->block) {                                                       \
      free(chunk);                                                             \
      return NULL;                                                             \
    }                                                                          \
    chunk->next = NULL;                                                        \
    return chunk;                                                              \
  }                                                                            \
                                                                               \
  static void name##Chunk_delete(name##Chunk *chunk) {                         \
    if (chunk->next) {                                                         \
      name##Chunk_delete(chunk->next);                                         \
    }                                                                          \
    free(chunk->block);                                                        \
    free(chunk);                                                               \
  }                                                                            \
                                                                               \
  void name##_init(name *pool, bool threadsafe, name##HashFn hash,             \
                   name##CompareFn compare) {                                  \
    pool->threadsafe = threadsafe;                                             \
    if (threadsafe) {                                                          \
      rwlock_init(&pool->rwlock);                                              \
    }                                                                          \
                                                                               \
    /* Initial chunk allocation */                                             \
    pool->chunk = pool->last =                                                 \
        name##Chunk_create(DEFAULT_MAX_VALUES_PER_CHUNK * sizeof(value_type)); \
    pool->tail = pool->chunk->block;                                           \
    pool->end = pool->tail + pool->chunk->sz;                                  \
                                                                               \
    name##HashSet_init(&pool->hash_set, DEFAULT_TABLE_SIZE, hash, compare);    \
  }                                                                            \
                                                                               \
  void name##_finalize(name *pool) {                                           \
    name##HashSet_finalize(&pool->hash_set);                                   \
    name##Chunk_delete(pool->chunk);                                           \
  }                                                                            \
                                                                               \
  const value_type *name##_intern(name *pool, const value_type *value,         \
                                  uint32_t value_size) {                       \
    if (pool->threadsafe) {                                                    \
      rwlock_read_lock(&pool->rwlock);                                         \
    }                                                                          \
                                                                               \
    /* Lookup existing interned value */                                       \
    value_type *existing =                                                     \
        name##HashSet_find(&pool->hash_set, value, value_size, NULL);          \
                                                                               \
    if (pool->threadsafe) {                                                    \
      rwlock_read_unlock(&pool->rwlock);                                       \
    }                                                                          \
                                                                               \
    if (existing) return existing;                                             \
                                                                               \
    if (pool->threadsafe) {                                                    \
      rwlock_write_lock(&pool->rwlock);                                        \
    }                                                                          \
                                                                               \
    /* Allocate new chunk if needed */                                         \
    if (pool->tail + value_size >= pool->end) {                                \
      uint32_t new_chunk_size =                                                \
          MAX_VALUE(DEFAULT_MAX_VALUES_PER_CHUNK * sizeof(value_type),         \
                    compute_nearest_pow2_gte(value_size * 16));                \
                                                                               \
      pool->last->next = name##Chunk_create(new_chunk_size);                   \
      pool->last = pool->last->next;                                           \
      pool->tail = pool->last->block;                                          \
      pool->end = pool->tail + pool->last->sz;                                 \
    }                                                                          \
                                                                               \
    /* Copy value into chunk */                                                \
    value_type *stored = (value_type *)pool->tail;                             \
    memmove(pool->tail, value, value_size);                                    \
    pool->tail += value_size;                                                  \
                                                                               \
    name##HashSet_insert(&pool->hash_set, stored, value_size);                 \
                                                                               \
    if (pool->threadsafe) {                                                    \
      rwlock_write_unlock(&pool->rwlock);                                      \
    }                                                                          \
                                                                               \
    return stored;                                                             \
  }

#ifdef __cplusplus
}
#endif

#endif /* COM_GITHUB_JEFFMANZIONE_INTERN_INTERN_H_ */
